# How it works

## Reducers

A special feature of Movex is that the reducer runs both on the Client and the Server, im order to make features as **Server Authority** and **Private/Secret State** possible.

### Client Runner

The client is just an optimization, and it takes advantage of the above mentioned quality of _determinism_ (same input always returns the same output), which means that we can run it on the client even before it gets sent to the server for validation, and thus render the next state without any lag.

See the secion on [State Mismatch Resynchronization](#remote-state-mismatch-resynchronization) on what happens when the remote states get out of sync and how does movex reconcile them.

### Server Runner

Although, the reducer runs on the client, the Server is always the **authority**! **This is the feature that enables _Server Side Authority_ without writing server specific code.**
_Note, this feature will only work with JS/TS codebases for the initial releases, and it will still need to be deployed manually (most likely via Docker). This is still a Work In Progress._

Here is what the Server Runner does:

1. Receives an action and processes the next state.
2. Sends an acknowledgemnt back to the sender containing the checksum of the processed state.
3. Forwards the action to the rest of the clients subscribed to that resource (peers).
4. Computes and Stores Private State Fragments until a future _revelation_ event. (See the section on [Secret State & Private Actions](#private-actions--secret-state)).
5. Calls the `$canRevealPrivateState` Native Action after each incoming Private Action. (This only gets called on the server)

## How Does the Private Action/Secret State actually works?

A __*Private Action*__ can only be sent in pair with a __*Public Action*__. The public action is needed to create the changes in the Public State in order for the `$canRevealPrivateState` handler to determine if it can reconcile the states or not yet. Think about it as a record of the private action being taken (could be a change of status for that player), without actually revealing the content of the action.

- **On The Client**

The sender's client, calls the reducer with the private action which will simply return the next state, BUT disregards the paired public one as that is only relevant to its peers (the rest of the clients).

- **On the Server**

The server will call the reducer with the private action, but knowing behind the scenes that is a private action, it will do something different with the result. Instead of simply merging it into the publc state, it will compute a deltaÂ from the prev to the next, and store that as a Client Private Fragment (delta) along with the action. This will allow the Sender Client to always get the _Private State_ even after a resource refetch, while all the others to get the _Public State_ or their own _Private State_ (in case they have dispatched Private Actions as well and the state hasn't reconciled yet).

## Remote State Mismatch Resynchronization (WIP)

Sometimes there might be mismatches in the client state and the server state. This could be due to network errors, bugs in the code or who knows what. Dealing with Shared State is hard :), but don't fret, Movex has some solutions:

##### 1. Use The Checksums to its advantage (Optimal)

 First of all it can take advantage of the state checksums. Each Forwarded/Acknowledge Action contains the prev and next state checksum, so the clients will be able to compare that with the locally computed next checksum and proceed accordingly given the outcome.


**If they match all is good ðŸ¥³, if not we take advantage of the following:**

The client will always store the last server reconciled checksum with its state (just in case it's needed to recompile). This will be derived from the ack/fwd received from the server, containing the next state checksum. If the client computes the same checksum than that becomes the last reconciled. If not, the below _Strategy_ needs to happen.

The server also stores a map of each checksum and the action that derived it in the order in which it was received. *(TODO: This could become big pretty early on, so there might be some optimization done.)*

When the server acks/forwards an action, and the checksum from the local state don't match, the client responds back with the last reconciled checksum it has, and the server will respond with all the actions from that point in the order of application. In theory this should set the two states in sync again, but there might be some other issues (especially if in the middle of the payload there was another action â€“Â or should it be an issue?)

When the client receives the reconciliatory actions (since it's reconciled state and checksum) it applies them right away and computes the next state (without intermediary renders I would say, since they might have already show some of them) and simply render the end result.

##### 2. Ask for the whole State Again (Sub Optimal but rare)

If the above doesn't work, for whatever reason, again dealing with Shared State is hard, we have the ultimate sling shot:

The Client Sends for help to the Server and the Server will respond with the latest version of the reconciled state. This should set things straight for another while, but in theory this shouldn't really happen too often. Hopefully not at all! ðŸ˜‡ 
  
> Note: This is still a WIP and we'll have to come up with proper tests and validation for this as well as probably more optimizations and heuristics