# Actions

Actions, like in Redux or Flux are simple commands paired with input that are sent to a reducer in order to compute the next state.

```ts

type Action = {
  type: 'incrementBy';
  payload: number;
}

```

## Public Actions

A Public Action, as its name implies is an Action that modifies the shared state (aka the public state), so everyone subscribed to it can get notified and see it.

```ts
type PublicAction = {
  type: 'incrementBy';
  payload: number;
  isPrivate?: false;
}
```

## Private Actions & Secret State

The State resulted from these actions MUST NOT be seen by the other peers/players in a game, until a future revelatory event. This is really useful in submission based games like poker when you don't want to show the whole state (cards) to each player until everyone submits.

```ts
type PrivateAction = {
  type: 'incrementBy';
  payload: number;
  isPrivate: true;
}
```

## Revelatory Action (Check)

The Revelatory Action (Check) is what determines when the private fragments of the State should reconcile back into a next public version.

It is part of the Reducer, and it is the only code that runs only on the Server, but it's minimal and part of the same Reducer that runs on the Client, which makes movex almoooost serverless :).

Here's how it works:

```ts
// *Note Api might change

type State = {
  playerA: {
    submitted: boolean;
    moves: Move[] | undefined;
  };
  playerB: {
    submitted: boolean;
    moves: Move[] | undefined;
  };
}

const counterReducer = {
  submitMoves: (state, action): State => {
    
  },
  setSubmitted: (state, action): State => {
    
  },

}

const gameReducer = (state = initialCounterState, action: CounterActions) => {
  if (action.type === 'submitMoves') {
    const { payload } = action;

    return {
      ...state,
      // Apply the next submission to the submitting player
      [payload.playerId]: {
        submitted: true,
        moves: payload.moves, // reveal the moves
      }
    };
  }

  if (action.type === 'setSubmitted') {
    const { payload } = action;

    return {
      ...state,
      // Apply the next submission to the submitting player
      [payload.playerId]: {
        // Set the status to submitted so the other player can see I submitted
        //  and also for the canReveal Validation to determine when to reconcile
        submitted: true, 
        moves: [], // hide the moves
      }
    };
  }

  return state;
};

// As a static method on the reducer function to check wether the  
//  It returns true when it's time to reveal all the private states by 
//  reconciling them all into the Public State
gameReducer.$canRevealPrivateState: (state): boolean => {
  // If both players submitted than it's time to Reveal the moves!!!
  return state.playerA.submitted && state.playerB.submitted;
}

dispatchPrivate(
  resourceIdentifier,
{
  type: 'submitMoves',
  payload: {
    playerId: 'playerA',
    moves: ['e2e4', 'f2f4'],
  }
  isPrivate: true, 
},
{
  type: 'setSubmitted',
  payload: {
    playerId: 'playerA',
  }
})

```